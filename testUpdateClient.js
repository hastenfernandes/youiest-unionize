// Generated by CoffeeScript 1.6.2
this.user = 'wiber';

this.recFrom = 'picture';

ConsoleMe.enabled = true;

Meteor.methods({
  "dummyInsert": function(args) {
    var one, two;

    if (!args) {
      args = user;
    }
    one = WI.insert({
      '_id': args
    });
    two = W.insert({
      '_id': args
    });
    return one;
  },
  "clearDb": function() {
    var one, two;

    one = W.remove({});
    two = WI.remove({});
    smite(one, two, 'clearDb buckle my boots', WI.find({}).count(), eval(s));
    return WI.findOne({});
  }
});

this.generateRecommend = function(i) {
  return {
    to: user + i,
    from: recFrom + i
  };
};

Meteor.startup(function() {
  return;
  var testing;

  if (Meteor.isClient) {
    testing = 0;
    Tinytest.addAsync('clear - ' + testing + ' call clearDb server clears db and W goes to 0 items', function(test, next) {
      return Meteor.call('clearDb', function(res, err) {
        var one;

        one = WI.find({}).count();
        test.equal(one, 0);
        return next();
      });
    });
    testing++;
    Tinytest.addAsync('clear - ' + testing + ' call clearDb server clears db and WI goes to 0 items', function(test, next) {
      var two;

      two = WI.find({}).count();
      test.equal(two, 0);
      return next();
    });
    testing++;
    Tinytest.add('insert - ' + testing + ' dummyInsert creates WI user object synced to client', function(test, next) {
      return Meteor.call('dummyInsert', user, function(res, err) {
        var userCreated;

        userCreated = WI.findOne({
          '_id': user
        });
        smite(userCreated, user);
        test.equal(userCreated._id, user);
        return next();
      });
    });
    testing++;
    Tinytest.addAsync('update - ' + testing + ' clientside update of WI should hook same inserted into W', function(test, next) {
      var rec;

      rec = generateRecommend(testing);
      connect(rec);
      return Tracker.autorun(function(computation) {
        var one;

        one = W.findOne({
          from: rec.from,
          to: rec.to
        });
        smite(rec, one, testing, 'testing inserted', eval(s));
        if (!!one) {
          test.equal(one.from, rec.from);
          return next();
        }
      });
    });
    testing++;
    Tinytest.addAsync('update - ' + testing + ' client WI.outbox -> server W -> client WI.inbox', function(test, next) {
      var rec;

      rec = generateRecommend(testing);
      connect(rec);
      return Tracker.autorun(function(computation) {
        var two;

        two = WI.findOne({
          _id: rec.to
        });
        smite(rec, two, testing, 'testing update outbox to inbox', eval(s));
        if (!!two.inbox) {
          test.equal(two.inbox[0].from, rec.from);
          return next();
        }
      });
    });
    testing++;
    Tinytest.addAsync('feed - ' + testing + ' client WI.feed has ten dummy items hooked in after server sees feed field', function(test, next) {
      WI.update({
        _id: user
      }, {
        feed: 'nothing'
      });
      return Tracker.autorun(function(computation) {
        var feed;

        smite(feed = WI.find({
          _id: 'wiber'
        }).fetch()[0].feed, eval(s));
        if (!!feed[3].journey) {
          test.equal(Object.keys(feed[3].journey[0])[0], 'feed');
          return next();
        }
      });
    });
    Tinytest.addAsync('update - ' + testing + ' client WI.outbox -> server W -> client WI.inbox', function(test, next) {
      var rec;

      rec = generateRecommend(testing);
      connect(rec);
      return Tracker.autorun(function(computation) {
        var two;

        two = WI.findOne({
          _id: rec.to
        });
        smite(rec, two, testing, 'testing update outbox to inbox', eval(s));
        if (!!two.inbox) {
          test.equal(two.inbox[0].from, rec.from);
          return next();
        }
      });
    });
    testing++;
    return Tinytest.addAsync('session - ' + testing + ' assure us that dot notation does not rerun tracker', function(test, next) {
      var rec, sending, sessionTracker;

      sending = WI.findOne({
        _id: user
      }).sending;
      Session.set('sending', sending);
      smite(sending, 'should be undefined', eval(s));
      sessionTracker = 0;
      connect(generateRecommend(testing++));
      rec = generateRecommend(testing++);
      connect(rec);
      smite(sending, 'should be undefined', eval(s));
      setTimeout((function() {
        rec = generateRecommend(testing++);
        return connect(rec);
      }), 500);
      setTimeout((function() {
        rec = generateRecommend(testing++);
        return connect(rec);
      }), 250);
      return Tracker.autorun(function(computation) {
        var inbox;

        smite(inbox = WI.findOne({
          _id: user
        }).inbox, 'should INBOX', eval(s));
        smite(sending = WI.findOne({
          _id: user
        }).sending, 'should sending', eval(s));
        sessionTracker++;
        smite(sending, eval(s));
        smite(sessionTracker, 'did this run multiple times?', inbox, eval(s));
        if (!(sessionTracker = 1)) {
          test.equal(WI.find({
            _id: 'wiber'
          }).fetch()[0].sending[0], Session.get('sending'));
          return next();
        }
      });
    });
  }
});
