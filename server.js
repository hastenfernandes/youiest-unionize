// Generated by CoffeeScript 1.6.2
var WIAfterUpdate, afterModifier;

smite(eval(s));

W.before.insert(function(userId, doc) {
  doc.createdAt = Date.now();
  if (!doc.journey) {
    doc.journey = [];
  }
  doc.journey.push({
    'serverCreated': new Date().getTime()
  });
  smite(doc, 'inserting this in hook', eval(s));
});

W.after.insert(function(userId, doc) {
  if (!WIFound(doc.to)) {
    smite('no target nemo found', eval(s));
    WI.insert({
      _id: doc.to
    });
  }
  WI.update({
    _id: doc.to
  }, {
    '$push': {
      inbox: {
        from: doc.from,
        to: doc.to
      }
    }
  });
  smite(WI.findOne, 'found this one in WI');
});

this.modModifier = {};

modModifier.outbox = function(modifier, userId) {
  var from, inserted, new_key, old_key, to;

  old_key = 'outbox';
  new_key = 'sending';
  if (old_key !== new_key) {
    smite(modifier, 'needs a new agenda', eval(s));
    smite(eval(Object.defineProperty(modifier.$push, new_key, Object.getOwnPropertyDescriptor(modifier.$push, old_key))));
    smite(eval(delete modifier.$push[old_key], 'deleted key', eval(s)));
  }
  smite('did we insert into W?', modifier, modifier.$push, from = modifier.$push.sending.from, to = modifier.$push.sending.to, eval(s));
  inserted = W.insert({
    to: to,
    from: from
  });
  smite(inserted, 'how long did the insert hook take? usually 30ms', eval(s));
  return modifier;
};

this.generateRecommend = function(i) {
  return {
    to: user + i,
    from: recFrom + i,
    journey: [
      {
        feed: new Date().getTime()
      }
    ]
  };
};

modModifier.feed = function(modifier, doc, userId) {
  smite(doc, 'modModifier.feed doc', eval(s));
  if (!(doc.feed instanceof Array)) {
    if (!(modifier.feed instanceof Array)) {
      smite(modifier, doc, 'modifier, doc', eval(s));
      return modifier.feed = [];
    }
  }
};

afterModifier = {};

this.feedMe = function(docId) {
  var fed, i, one, _i, _len, _ref;

  fed = [];
  _ref = 'abcdefghiklmo';
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    i = _ref[_i];
    fed.push(generateRecommend(i));
  }
  one = WI.update({
    _id: docId
  }, {
    '$pushAll': {
      'feed': fed
    }
  });
  return smite(one, 'oneoneone done', eval(s));
};

afterModifier.feed = function(modifier, doc, userId) {
  var docId, stackSize, userObject;

  docId = arguments[1]._id;
  smite(arguments, docId, doc.feed.length, 'doc afterModifier', eval(s));
  if (!stackSize) {
    stackSize = 5;
  }
  if (!(doc.feed.length >= stackSize)) {
    /* WI.find({_id:'wiber'}).fetch()[0].feed # works
    unless afterModifier[docId] 
      afterModifier[docId] = _.throttle feedMe(docId), 250
      setTimeout (->
        delete afterModifier[docId]
      ), 300
    */

    userObject = WI.findOne({
      _id: docId
    });
    smite(userObject, userObject.feed.length, 'almost userObject', eval(s));
    if (!(userObject.feed.length >= stackSize)) {
      return smite(feedMe(docId), 'feedMe(docId)', eval(s));
    }
  }
};

WI.before.update(function(userId, doc, fieldNames, modifier, options) {
  var fieldName, _i, _len, _results;

  _results = [];
  for (_i = 0, _len = fieldNames.length; _i < _len; _i++) {
    fieldName = fieldNames[_i];
    if (_.has(modModifier, fieldName)) {
      smite(fieldName, doc, 'spinning modModifier', eval(s));
      _results.push(smite(modifier = modModifier[fieldName](modifier, doc, userId)));
    } else {
      _results.push(smite('we dont have a function for: ', fieldname, eval(s)));
    }
  }
  return _results;
});

WIAfterUpdate = WI.after.update(function(userId, doc, fieldNames, modifier, options) {
  var fieldName, _i, _len, _results;

  _results = [];
  for (_i = 0, _len = fieldNames.length; _i < _len; _i++) {
    fieldName = fieldNames[_i];
    if (_.has(afterModifier, fieldName)) {
      smite(fieldName, 'spinning afterModifier', eval(s));
      _results.push(modifier = afterModifier[fieldName](modifier, doc, userId));
    } else {
      _results.push(smite('we dont have a function for: ', fieldname, eval(s)));
    }
  }
  return _results;
});

Meteor.publish(null, function() {
  return W.find({});
});

Meteor.publish(null, function() {
  return WI.find({});
});
